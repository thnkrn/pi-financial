/*
Pi.User.API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package go_client

import (
	"encoding/json"
)

// checks if the PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem{}

// PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem struct for PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem
type PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem struct {
	TradingAccountNo NullableString `json:"tradingAccountNo,omitempty"`
	AccountType      NullableString `json:"accountType,omitempty"`
	TransactionType  NullableString `json:"transactionType,omitempty"`
	RpType           NullableString `json:"rpType,omitempty"`
	BankCode         NullableString `json:"bankCode,omitempty"`
	BankAccountNo    NullableString `json:"bankAccountNo,omitempty"`
	BankAccountType  NullableString `json:"bankAccountType,omitempty"`
	PayType          NullableString `json:"payType,omitempty"`
	EffectiveDate    NullableString `json:"effectiveDate,omitempty"`
	EndDate          NullableString `json:"endDate,omitempty"`
	AccountCodeType  NullableString `json:"accountCodeType,omitempty"`
	ExchangeMarket   NullableString `json:"exchangeMarket,omitempty"`
}

// NewPiUserApplicationServicesLegacyUserInfoBankAccountInfoItem instantiates a new PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewPiUserApplicationServicesLegacyUserInfoBankAccountInfoItem() *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem {
	this := PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem{}
	return &this
}

// NewPiUserApplicationServicesLegacyUserInfoBankAccountInfoItemWithDefaults instantiates a new PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewPiUserApplicationServicesLegacyUserInfoBankAccountInfoItemWithDefaults() *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem {
	this := PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem{}
	return &this
}

// GetTradingAccountNo returns the TradingAccountNo field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetTradingAccountNo() string {
	if o == nil || IsNil(o.TradingAccountNo.Get()) {
		var ret string
		return ret
	}
	return *o.TradingAccountNo.Get()
}

// GetTradingAccountNoOk returns a tuple with the TradingAccountNo field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetTradingAccountNoOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.TradingAccountNo.Get(), o.TradingAccountNo.IsSet()
}

// HasTradingAccountNo returns a boolean if a field has been set.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) HasTradingAccountNo() bool {
	if o != nil && o.TradingAccountNo.IsSet() {
		return true
	}

	return false
}

// SetTradingAccountNo gets a reference to the given NullableString and assigns it to the TradingAccountNo field.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetTradingAccountNo(v string) {
	o.TradingAccountNo.Set(&v)
}

// SetTradingAccountNoNil sets the value for TradingAccountNo to be an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetTradingAccountNoNil() {
	o.TradingAccountNo.Set(nil)
}

// UnsetTradingAccountNo ensures that no value is present for TradingAccountNo, not even an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) UnsetTradingAccountNo() {
	o.TradingAccountNo.Unset()
}

// GetAccountType returns the AccountType field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetAccountType() string {
	if o == nil || IsNil(o.AccountType.Get()) {
		var ret string
		return ret
	}
	return *o.AccountType.Get()
}

// GetAccountTypeOk returns a tuple with the AccountType field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetAccountTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.AccountType.Get(), o.AccountType.IsSet()
}

// HasAccountType returns a boolean if a field has been set.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) HasAccountType() bool {
	if o != nil && o.AccountType.IsSet() {
		return true
	}

	return false
}

// SetAccountType gets a reference to the given NullableString and assigns it to the AccountType field.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetAccountType(v string) {
	o.AccountType.Set(&v)
}

// SetAccountTypeNil sets the value for AccountType to be an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetAccountTypeNil() {
	o.AccountType.Set(nil)
}

// UnsetAccountType ensures that no value is present for AccountType, not even an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) UnsetAccountType() {
	o.AccountType.Unset()
}

// GetTransactionType returns the TransactionType field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetTransactionType() string {
	if o == nil || IsNil(o.TransactionType.Get()) {
		var ret string
		return ret
	}
	return *o.TransactionType.Get()
}

// GetTransactionTypeOk returns a tuple with the TransactionType field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetTransactionTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.TransactionType.Get(), o.TransactionType.IsSet()
}

// HasTransactionType returns a boolean if a field has been set.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) HasTransactionType() bool {
	if o != nil && o.TransactionType.IsSet() {
		return true
	}

	return false
}

// SetTransactionType gets a reference to the given NullableString and assigns it to the TransactionType field.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetTransactionType(v string) {
	o.TransactionType.Set(&v)
}

// SetTransactionTypeNil sets the value for TransactionType to be an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetTransactionTypeNil() {
	o.TransactionType.Set(nil)
}

// UnsetTransactionType ensures that no value is present for TransactionType, not even an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) UnsetTransactionType() {
	o.TransactionType.Unset()
}

// GetRpType returns the RpType field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetRpType() string {
	if o == nil || IsNil(o.RpType.Get()) {
		var ret string
		return ret
	}
	return *o.RpType.Get()
}

// GetRpTypeOk returns a tuple with the RpType field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetRpTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.RpType.Get(), o.RpType.IsSet()
}

// HasRpType returns a boolean if a field has been set.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) HasRpType() bool {
	if o != nil && o.RpType.IsSet() {
		return true
	}

	return false
}

// SetRpType gets a reference to the given NullableString and assigns it to the RpType field.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetRpType(v string) {
	o.RpType.Set(&v)
}

// SetRpTypeNil sets the value for RpType to be an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetRpTypeNil() {
	o.RpType.Set(nil)
}

// UnsetRpType ensures that no value is present for RpType, not even an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) UnsetRpType() {
	o.RpType.Unset()
}

// GetBankCode returns the BankCode field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetBankCode() string {
	if o == nil || IsNil(o.BankCode.Get()) {
		var ret string
		return ret
	}
	return *o.BankCode.Get()
}

// GetBankCodeOk returns a tuple with the BankCode field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetBankCodeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.BankCode.Get(), o.BankCode.IsSet()
}

// HasBankCode returns a boolean if a field has been set.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) HasBankCode() bool {
	if o != nil && o.BankCode.IsSet() {
		return true
	}

	return false
}

// SetBankCode gets a reference to the given NullableString and assigns it to the BankCode field.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetBankCode(v string) {
	o.BankCode.Set(&v)
}

// SetBankCodeNil sets the value for BankCode to be an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetBankCodeNil() {
	o.BankCode.Set(nil)
}

// UnsetBankCode ensures that no value is present for BankCode, not even an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) UnsetBankCode() {
	o.BankCode.Unset()
}

// GetBankAccountNo returns the BankAccountNo field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetBankAccountNo() string {
	if o == nil || IsNil(o.BankAccountNo.Get()) {
		var ret string
		return ret
	}
	return *o.BankAccountNo.Get()
}

// GetBankAccountNoOk returns a tuple with the BankAccountNo field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetBankAccountNoOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.BankAccountNo.Get(), o.BankAccountNo.IsSet()
}

// HasBankAccountNo returns a boolean if a field has been set.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) HasBankAccountNo() bool {
	if o != nil && o.BankAccountNo.IsSet() {
		return true
	}

	return false
}

// SetBankAccountNo gets a reference to the given NullableString and assigns it to the BankAccountNo field.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetBankAccountNo(v string) {
	o.BankAccountNo.Set(&v)
}

// SetBankAccountNoNil sets the value for BankAccountNo to be an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetBankAccountNoNil() {
	o.BankAccountNo.Set(nil)
}

// UnsetBankAccountNo ensures that no value is present for BankAccountNo, not even an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) UnsetBankAccountNo() {
	o.BankAccountNo.Unset()
}

// GetBankAccountType returns the BankAccountType field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetBankAccountType() string {
	if o == nil || IsNil(o.BankAccountType.Get()) {
		var ret string
		return ret
	}
	return *o.BankAccountType.Get()
}

// GetBankAccountTypeOk returns a tuple with the BankAccountType field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetBankAccountTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.BankAccountType.Get(), o.BankAccountType.IsSet()
}

// HasBankAccountType returns a boolean if a field has been set.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) HasBankAccountType() bool {
	if o != nil && o.BankAccountType.IsSet() {
		return true
	}

	return false
}

// SetBankAccountType gets a reference to the given NullableString and assigns it to the BankAccountType field.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetBankAccountType(v string) {
	o.BankAccountType.Set(&v)
}

// SetBankAccountTypeNil sets the value for BankAccountType to be an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetBankAccountTypeNil() {
	o.BankAccountType.Set(nil)
}

// UnsetBankAccountType ensures that no value is present for BankAccountType, not even an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) UnsetBankAccountType() {
	o.BankAccountType.Unset()
}

// GetPayType returns the PayType field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetPayType() string {
	if o == nil || IsNil(o.PayType.Get()) {
		var ret string
		return ret
	}
	return *o.PayType.Get()
}

// GetPayTypeOk returns a tuple with the PayType field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetPayTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.PayType.Get(), o.PayType.IsSet()
}

// HasPayType returns a boolean if a field has been set.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) HasPayType() bool {
	if o != nil && o.PayType.IsSet() {
		return true
	}

	return false
}

// SetPayType gets a reference to the given NullableString and assigns it to the PayType field.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetPayType(v string) {
	o.PayType.Set(&v)
}

// SetPayTypeNil sets the value for PayType to be an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetPayTypeNil() {
	o.PayType.Set(nil)
}

// UnsetPayType ensures that no value is present for PayType, not even an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) UnsetPayType() {
	o.PayType.Unset()
}

// GetEffectiveDate returns the EffectiveDate field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetEffectiveDate() string {
	if o == nil || IsNil(o.EffectiveDate.Get()) {
		var ret string
		return ret
	}
	return *o.EffectiveDate.Get()
}

// GetEffectiveDateOk returns a tuple with the EffectiveDate field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetEffectiveDateOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.EffectiveDate.Get(), o.EffectiveDate.IsSet()
}

// HasEffectiveDate returns a boolean if a field has been set.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) HasEffectiveDate() bool {
	if o != nil && o.EffectiveDate.IsSet() {
		return true
	}

	return false
}

// SetEffectiveDate gets a reference to the given NullableString and assigns it to the EffectiveDate field.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetEffectiveDate(v string) {
	o.EffectiveDate.Set(&v)
}

// SetEffectiveDateNil sets the value for EffectiveDate to be an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetEffectiveDateNil() {
	o.EffectiveDate.Set(nil)
}

// UnsetEffectiveDate ensures that no value is present for EffectiveDate, not even an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) UnsetEffectiveDate() {
	o.EffectiveDate.Unset()
}

// GetEndDate returns the EndDate field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetEndDate() string {
	if o == nil || IsNil(o.EndDate.Get()) {
		var ret string
		return ret
	}
	return *o.EndDate.Get()
}

// GetEndDateOk returns a tuple with the EndDate field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetEndDateOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.EndDate.Get(), o.EndDate.IsSet()
}

// HasEndDate returns a boolean if a field has been set.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) HasEndDate() bool {
	if o != nil && o.EndDate.IsSet() {
		return true
	}

	return false
}

// SetEndDate gets a reference to the given NullableString and assigns it to the EndDate field.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetEndDate(v string) {
	o.EndDate.Set(&v)
}

// SetEndDateNil sets the value for EndDate to be an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetEndDateNil() {
	o.EndDate.Set(nil)
}

// UnsetEndDate ensures that no value is present for EndDate, not even an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) UnsetEndDate() {
	o.EndDate.Unset()
}

// GetAccountCodeType returns the AccountCodeType field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetAccountCodeType() string {
	if o == nil || IsNil(o.AccountCodeType.Get()) {
		var ret string
		return ret
	}
	return *o.AccountCodeType.Get()
}

// GetAccountCodeTypeOk returns a tuple with the AccountCodeType field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetAccountCodeTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.AccountCodeType.Get(), o.AccountCodeType.IsSet()
}

// HasAccountCodeType returns a boolean if a field has been set.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) HasAccountCodeType() bool {
	if o != nil && o.AccountCodeType.IsSet() {
		return true
	}

	return false
}

// SetAccountCodeType gets a reference to the given NullableString and assigns it to the AccountCodeType field.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetAccountCodeType(v string) {
	o.AccountCodeType.Set(&v)
}

// SetAccountCodeTypeNil sets the value for AccountCodeType to be an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetAccountCodeTypeNil() {
	o.AccountCodeType.Set(nil)
}

// UnsetAccountCodeType ensures that no value is present for AccountCodeType, not even an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) UnsetAccountCodeType() {
	o.AccountCodeType.Unset()
}

// GetExchangeMarket returns the ExchangeMarket field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetExchangeMarket() string {
	if o == nil || IsNil(o.ExchangeMarket.Get()) {
		var ret string
		return ret
	}
	return *o.ExchangeMarket.Get()
}

// GetExchangeMarketOk returns a tuple with the ExchangeMarket field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) GetExchangeMarketOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.ExchangeMarket.Get(), o.ExchangeMarket.IsSet()
}

// HasExchangeMarket returns a boolean if a field has been set.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) HasExchangeMarket() bool {
	if o != nil && o.ExchangeMarket.IsSet() {
		return true
	}

	return false
}

// SetExchangeMarket gets a reference to the given NullableString and assigns it to the ExchangeMarket field.
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetExchangeMarket(v string) {
	o.ExchangeMarket.Set(&v)
}

// SetExchangeMarketNil sets the value for ExchangeMarket to be an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) SetExchangeMarketNil() {
	o.ExchangeMarket.Set(nil)
}

// UnsetExchangeMarket ensures that no value is present for ExchangeMarket, not even an explicit nil
func (o *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) UnsetExchangeMarket() {
	o.ExchangeMarket.Unset()
}

func (o PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if o.TradingAccountNo.IsSet() {
		toSerialize["tradingAccountNo"] = o.TradingAccountNo.Get()
	}
	if o.AccountType.IsSet() {
		toSerialize["accountType"] = o.AccountType.Get()
	}
	if o.TransactionType.IsSet() {
		toSerialize["transactionType"] = o.TransactionType.Get()
	}
	if o.RpType.IsSet() {
		toSerialize["rpType"] = o.RpType.Get()
	}
	if o.BankCode.IsSet() {
		toSerialize["bankCode"] = o.BankCode.Get()
	}
	if o.BankAccountNo.IsSet() {
		toSerialize["bankAccountNo"] = o.BankAccountNo.Get()
	}
	if o.BankAccountType.IsSet() {
		toSerialize["bankAccountType"] = o.BankAccountType.Get()
	}
	if o.PayType.IsSet() {
		toSerialize["payType"] = o.PayType.Get()
	}
	if o.EffectiveDate.IsSet() {
		toSerialize["effectiveDate"] = o.EffectiveDate.Get()
	}
	if o.EndDate.IsSet() {
		toSerialize["endDate"] = o.EndDate.Get()
	}
	if o.AccountCodeType.IsSet() {
		toSerialize["accountCodeType"] = o.AccountCodeType.Get()
	}
	if o.ExchangeMarket.IsSet() {
		toSerialize["exchangeMarket"] = o.ExchangeMarket.Get()
	}
	return toSerialize, nil
}

type NullablePiUserApplicationServicesLegacyUserInfoBankAccountInfoItem struct {
	value *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem
	isSet bool
}

func (v NullablePiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) Get() *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem {
	return v.value
}

func (v *NullablePiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) Set(val *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) {
	v.value = val
	v.isSet = true
}

func (v NullablePiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) IsSet() bool {
	return v.isSet
}

func (v *NullablePiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullablePiUserApplicationServicesLegacyUserInfoBankAccountInfoItem(val *PiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) *NullablePiUserApplicationServicesLegacyUserInfoBankAccountInfoItem {
	return &NullablePiUserApplicationServicesLegacyUserInfoBankAccountInfoItem{value: val, isSet: true}
}

func (v NullablePiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullablePiUserApplicationServicesLegacyUserInfoBankAccountInfoItem) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
