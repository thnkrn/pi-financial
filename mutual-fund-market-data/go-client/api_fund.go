/*
Pi.FundMarketData.API, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package go_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// FundAPIService FundAPI service
type FundAPIService service

type ApiInternalFundsSearchGetRequest struct {
	ctx        context.Context
	ApiService *FundAPIService
	keyword    *string
}

func (r ApiInternalFundsSearchGetRequest) Keyword(keyword string) ApiInternalFundsSearchGetRequest {
	r.keyword = &keyword
	return r
}

func (r ApiInternalFundsSearchGetRequest) Execute() (*PiFundMarketDataAPIModelsResponsesFundSearchResponseIEnumerableApiResponse, *http.Response, error) {
	return r.ApiService.InternalFundsSearchGetExecute(r)
}

/*
InternalFundsSearchGet Method for InternalFundsSearchGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInternalFundsSearchGetRequest
*/
func (a *FundAPIService) InternalFundsSearchGet(ctx context.Context) ApiInternalFundsSearchGetRequest {
	return ApiInternalFundsSearchGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiFundMarketDataAPIModelsResponsesFundSearchResponseIEnumerableApiResponse
func (a *FundAPIService) InternalFundsSearchGetExecute(r ApiInternalFundsSearchGetRequest) (*PiFundMarketDataAPIModelsResponsesFundSearchResponseIEnumerableApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiFundMarketDataAPIModelsResponsesFundSearchResponseIEnumerableApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundAPIService.InternalFundsSearchGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/internal/funds/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInternalFundsSymbolProfileGetRequest struct {
	ctx        context.Context
	ApiService *FundAPIService
	symbol     string
}

func (r ApiInternalFundsSymbolProfileGetRequest) Execute() (*PiFundMarketDataAPIModelsResponsesFundProfileResponseApiResponse, *http.Response, error) {
	return r.ApiService.InternalFundsSymbolProfileGetExecute(r)
}

/*
InternalFundsSymbolProfileGet Method for InternalFundsSymbolProfileGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param symbol
	@return ApiInternalFundsSymbolProfileGetRequest
*/
func (a *FundAPIService) InternalFundsSymbolProfileGet(ctx context.Context, symbol string) ApiInternalFundsSymbolProfileGetRequest {
	return ApiInternalFundsSymbolProfileGetRequest{
		ApiService: a,
		ctx:        ctx,
		symbol:     symbol,
	}
}

// Execute executes the request
//
//	@return PiFundMarketDataAPIModelsResponsesFundProfileResponseApiResponse
func (a *FundAPIService) InternalFundsSymbolProfileGetExecute(r ApiInternalFundsSymbolProfileGetRequest) (*PiFundMarketDataAPIModelsResponsesFundProfileResponseApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiFundMarketDataAPIModelsResponsesFundProfileResponseApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundAPIService.InternalFundsSymbolProfileGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/internal/funds/{symbol}/profile"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol"+"}", url.PathEscape(parameterValueToString(r.symbol, "symbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInternalFundsSymbolTradableDatesGetRequest struct {
	ctx          context.Context
	ApiService   *FundAPIService
	symbol       string
	tradeType    *PiFundMarketDataConstantsTradeSide
	switchSymbol *string
}

func (r ApiInternalFundsSymbolTradableDatesGetRequest) TradeType(tradeType PiFundMarketDataConstantsTradeSide) ApiInternalFundsSymbolTradableDatesGetRequest {
	r.tradeType = &tradeType
	return r
}

func (r ApiInternalFundsSymbolTradableDatesGetRequest) SwitchSymbol(switchSymbol string) ApiInternalFundsSymbolTradableDatesGetRequest {
	r.switchSymbol = &switchSymbol
	return r
}

func (r ApiInternalFundsSymbolTradableDatesGetRequest) Execute() (*SystemDateTimeIEnumerableApiResponse, *http.Response, error) {
	return r.ApiService.InternalFundsSymbolTradableDatesGetExecute(r)
}

/*
InternalFundsSymbolTradableDatesGet Method for InternalFundsSymbolTradableDatesGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param symbol
	@return ApiInternalFundsSymbolTradableDatesGetRequest
*/
func (a *FundAPIService) InternalFundsSymbolTradableDatesGet(ctx context.Context, symbol string) ApiInternalFundsSymbolTradableDatesGetRequest {
	return ApiInternalFundsSymbolTradableDatesGetRequest{
		ApiService: a,
		ctx:        ctx,
		symbol:     symbol,
	}
}

// Execute executes the request
//
//	@return SystemDateTimeIEnumerableApiResponse
func (a *FundAPIService) InternalFundsSymbolTradableDatesGetExecute(r ApiInternalFundsSymbolTradableDatesGetRequest) (*SystemDateTimeIEnumerableApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SystemDateTimeIEnumerableApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundAPIService.InternalFundsSymbolTradableDatesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/internal/funds/{symbol}/tradable-dates"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol"+"}", url.PathEscape(parameterValueToString(r.symbol, "symbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tradeType == nil {
		return localVarReturnValue, nil, reportError("tradeType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "TradeType", r.tradeType, "form", "")
	if r.switchSymbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SwitchSymbol", r.switchSymbol, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInternalFundsTradingProfilesPostRequest struct {
	ctx         context.Context
	ApiService  *FundAPIService
	requestBody *[]string
}

func (r ApiInternalFundsTradingProfilesPostRequest) RequestBody(requestBody []string) ApiInternalFundsTradingProfilesPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiInternalFundsTradingProfilesPostRequest) Execute() (*PiFundMarketDataAPIModelsResponsesFundTradingProfileResponseIEnumerableApiResponse, *http.Response, error) {
	return r.ApiService.InternalFundsTradingProfilesPostExecute(r)
}

/*
InternalFundsTradingProfilesPost Method for InternalFundsTradingProfilesPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInternalFundsTradingProfilesPostRequest
*/
func (a *FundAPIService) InternalFundsTradingProfilesPost(ctx context.Context) ApiInternalFundsTradingProfilesPostRequest {
	return ApiInternalFundsTradingProfilesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiFundMarketDataAPIModelsResponsesFundTradingProfileResponseIEnumerableApiResponse
func (a *FundAPIService) InternalFundsTradingProfilesPostExecute(r ApiInternalFundsTradingProfilesPostRequest) (*PiFundMarketDataAPIModelsResponsesFundTradingProfileResponseIEnumerableApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiFundMarketDataAPIModelsResponsesFundTradingProfileResponseIEnumerableApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundAPIService.InternalFundsTradingProfilesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/internal/funds/trading-profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureFundsMarketBasketMarketSummariesGetRequest struct {
	ctx          context.Context
	ApiService   *FundAPIService
	marketBasket PiFundMarketDataConstantsMarketBasket
	interval     *PiFundMarketDataConstantsInterval
}

func (r ApiSecureFundsMarketBasketMarketSummariesGetRequest) Interval(interval PiFundMarketDataConstantsInterval) ApiSecureFundsMarketBasketMarketSummariesGetRequest {
	r.interval = &interval
	return r
}

func (r ApiSecureFundsMarketBasketMarketSummariesGetRequest) Execute() (*PiFundMarketDataAPIModelsResponsesFundMarketSummaryResponseIEnumerableApiResponse, *http.Response, error) {
	return r.ApiService.SecureFundsMarketBasketMarketSummariesGetExecute(r)
}

/*
SecureFundsMarketBasketMarketSummariesGet Method for SecureFundsMarketBasketMarketSummariesGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param marketBasket
	@return ApiSecureFundsMarketBasketMarketSummariesGetRequest
*/
func (a *FundAPIService) SecureFundsMarketBasketMarketSummariesGet(ctx context.Context, marketBasket PiFundMarketDataConstantsMarketBasket) ApiSecureFundsMarketBasketMarketSummariesGetRequest {
	return ApiSecureFundsMarketBasketMarketSummariesGetRequest{
		ApiService:   a,
		ctx:          ctx,
		marketBasket: marketBasket,
	}
}

// Execute executes the request
//
//	@return PiFundMarketDataAPIModelsResponsesFundMarketSummaryResponseIEnumerableApiResponse
func (a *FundAPIService) SecureFundsMarketBasketMarketSummariesGetExecute(r ApiSecureFundsMarketBasketMarketSummariesGetRequest) (*PiFundMarketDataAPIModelsResponsesFundMarketSummaryResponseIEnumerableApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiFundMarketDataAPIModelsResponsesFundMarketSummaryResponseIEnumerableApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundAPIService.SecureFundsMarketBasketMarketSummariesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/funds/{marketBasket}/market-summaries"
	localVarPath = strings.Replace(localVarPath, "{"+"marketBasket"+"}", url.PathEscape(parameterValueToString(r.marketBasket, "marketBasket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureFundsMarketBasketMarketSummariesV2GetRequest struct {
	ctx          context.Context
	ApiService   *FundAPIService
	marketBasket PiFundMarketDataConstantsMarketBasket
	interval     *PiFundMarketDataConstantsInterval
	page         *int32
	pageSize     *int32
}

func (r ApiSecureFundsMarketBasketMarketSummariesV2GetRequest) Interval(interval PiFundMarketDataConstantsInterval) ApiSecureFundsMarketBasketMarketSummariesV2GetRequest {
	r.interval = &interval
	return r
}

func (r ApiSecureFundsMarketBasketMarketSummariesV2GetRequest) Page(page int32) ApiSecureFundsMarketBasketMarketSummariesV2GetRequest {
	r.page = &page
	return r
}

func (r ApiSecureFundsMarketBasketMarketSummariesV2GetRequest) PageSize(pageSize int32) ApiSecureFundsMarketBasketMarketSummariesV2GetRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiSecureFundsMarketBasketMarketSummariesV2GetRequest) Execute() (*PiFundMarketDataAPIModelsResponsesFundMarketSummaryResponseIEnumerableApiPaginateResponse, *http.Response, error) {
	return r.ApiService.SecureFundsMarketBasketMarketSummariesV2GetExecute(r)
}

/*
SecureFundsMarketBasketMarketSummariesV2Get Method for SecureFundsMarketBasketMarketSummariesV2Get

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param marketBasket
	@return ApiSecureFundsMarketBasketMarketSummariesV2GetRequest
*/
func (a *FundAPIService) SecureFundsMarketBasketMarketSummariesV2Get(ctx context.Context, marketBasket PiFundMarketDataConstantsMarketBasket) ApiSecureFundsMarketBasketMarketSummariesV2GetRequest {
	return ApiSecureFundsMarketBasketMarketSummariesV2GetRequest{
		ApiService:   a,
		ctx:          ctx,
		marketBasket: marketBasket,
	}
}

// Execute executes the request
//
//	@return PiFundMarketDataAPIModelsResponsesFundMarketSummaryResponseIEnumerableApiPaginateResponse
func (a *FundAPIService) SecureFundsMarketBasketMarketSummariesV2GetExecute(r ApiSecureFundsMarketBasketMarketSummariesV2GetRequest) (*PiFundMarketDataAPIModelsResponsesFundMarketSummaryResponseIEnumerableApiPaginateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiFundMarketDataAPIModelsResponsesFundMarketSummaryResponseIEnumerableApiPaginateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundAPIService.SecureFundsMarketBasketMarketSummariesV2Get")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/funds/{marketBasket}/market-summaries/v2"
	localVarPath = strings.Replace(localVarPath, "{"+"marketBasket"+"}", url.PathEscape(parameterValueToString(r.marketBasket, "marketBasket")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureFundsProfilesPostRequest struct {
	ctx         context.Context
	ApiService  *FundAPIService
	requestBody *[]string
}

func (r ApiSecureFundsProfilesPostRequest) RequestBody(requestBody []string) ApiSecureFundsProfilesPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSecureFundsProfilesPostRequest) Execute() (*PiFundMarketDataAPIModelsResponsesFundProfileResponseIEnumerableApiResponse, *http.Response, error) {
	return r.ApiService.SecureFundsProfilesPostExecute(r)
}

/*
SecureFundsProfilesPost Method for SecureFundsProfilesPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureFundsProfilesPostRequest

Deprecated
*/
func (a *FundAPIService) SecureFundsProfilesPost(ctx context.Context) ApiSecureFundsProfilesPostRequest {
	return ApiSecureFundsProfilesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiFundMarketDataAPIModelsResponsesFundProfileResponseIEnumerableApiResponse
//
// Deprecated
func (a *FundAPIService) SecureFundsProfilesPostExecute(r ApiSecureFundsProfilesPostRequest) (*PiFundMarketDataAPIModelsResponsesFundProfileResponseIEnumerableApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiFundMarketDataAPIModelsResponsesFundProfileResponseIEnumerableApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundAPIService.SecureFundsProfilesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/funds/profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureFundsSearchGetRequest struct {
	ctx        context.Context
	ApiService *FundAPIService
	keyword    *string
}

func (r ApiSecureFundsSearchGetRequest) Keyword(keyword string) ApiSecureFundsSearchGetRequest {
	r.keyword = &keyword
	return r
}

func (r ApiSecureFundsSearchGetRequest) Execute() (*PiFundMarketDataAPIModelsResponsesFundSearchResponseIEnumerableApiResponse, *http.Response, error) {
	return r.ApiService.SecureFundsSearchGetExecute(r)
}

/*
SecureFundsSearchGet Method for SecureFundsSearchGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureFundsSearchGetRequest
*/
func (a *FundAPIService) SecureFundsSearchGet(ctx context.Context) ApiSecureFundsSearchGetRequest {
	return ApiSecureFundsSearchGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiFundMarketDataAPIModelsResponsesFundSearchResponseIEnumerableApiResponse
func (a *FundAPIService) SecureFundsSearchGetExecute(r ApiSecureFundsSearchGetRequest) (*PiFundMarketDataAPIModelsResponsesFundSearchResponseIEnumerableApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiFundMarketDataAPIModelsResponsesFundSearchResponseIEnumerableApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundAPIService.SecureFundsSearchGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/funds/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureFundsSymbolHistoricalNavGetRequest struct {
	ctx        context.Context
	ApiService *FundAPIService
	symbol     string
	interval   *string
}

func (r ApiSecureFundsSymbolHistoricalNavGetRequest) Interval(interval string) ApiSecureFundsSymbolHistoricalNavGetRequest {
	r.interval = &interval
	return r
}

func (r ApiSecureFundsSymbolHistoricalNavGetRequest) Execute() (*PiFundMarketDataAPIModelsResponsesFundHistoricalNavResponseApiResponse, *http.Response, error) {
	return r.ApiService.SecureFundsSymbolHistoricalNavGetExecute(r)
}

/*
SecureFundsSymbolHistoricalNavGet Method for SecureFundsSymbolHistoricalNavGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param symbol
	@return ApiSecureFundsSymbolHistoricalNavGetRequest
*/
func (a *FundAPIService) SecureFundsSymbolHistoricalNavGet(ctx context.Context, symbol string) ApiSecureFundsSymbolHistoricalNavGetRequest {
	return ApiSecureFundsSymbolHistoricalNavGetRequest{
		ApiService: a,
		ctx:        ctx,
		symbol:     symbol,
	}
}

// Execute executes the request
//
//	@return PiFundMarketDataAPIModelsResponsesFundHistoricalNavResponseApiResponse
func (a *FundAPIService) SecureFundsSymbolHistoricalNavGetExecute(r ApiSecureFundsSymbolHistoricalNavGetRequest) (*PiFundMarketDataAPIModelsResponsesFundHistoricalNavResponseApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiFundMarketDataAPIModelsResponsesFundHistoricalNavResponseApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundAPIService.SecureFundsSymbolHistoricalNavGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/funds/{symbol}/historical-nav"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol"+"}", url.PathEscape(parameterValueToString(r.symbol, "symbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureFundsSymbolProfileGetRequest struct {
	ctx        context.Context
	ApiService *FundAPIService
	symbol     string
}

func (r ApiSecureFundsSymbolProfileGetRequest) Execute() (*PiFundMarketDataAPIModelsResponsesFundProfileResponseApiResponse, *http.Response, error) {
	return r.ApiService.SecureFundsSymbolProfileGetExecute(r)
}

/*
SecureFundsSymbolProfileGet Method for SecureFundsSymbolProfileGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param symbol
	@return ApiSecureFundsSymbolProfileGetRequest
*/
func (a *FundAPIService) SecureFundsSymbolProfileGet(ctx context.Context, symbol string) ApiSecureFundsSymbolProfileGetRequest {
	return ApiSecureFundsSymbolProfileGetRequest{
		ApiService: a,
		ctx:        ctx,
		symbol:     symbol,
	}
}

// Execute executes the request
//
//	@return PiFundMarketDataAPIModelsResponsesFundProfileResponseApiResponse
func (a *FundAPIService) SecureFundsSymbolProfileGetExecute(r ApiSecureFundsSymbolProfileGetRequest) (*PiFundMarketDataAPIModelsResponsesFundProfileResponseApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiFundMarketDataAPIModelsResponsesFundProfileResponseApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundAPIService.SecureFundsSymbolProfileGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/funds/{symbol}/profile"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol"+"}", url.PathEscape(parameterValueToString(r.symbol, "symbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureFundsSymbolSwitchingFundsGetRequest struct {
	ctx        context.Context
	ApiService *FundAPIService
	symbol     string
}

func (r ApiSecureFundsSymbolSwitchingFundsGetRequest) Execute() (*PiFundMarketDataAPIModelsResponsesSwitchingFundResponseApiResponse, *http.Response, error) {
	return r.ApiService.SecureFundsSymbolSwitchingFundsGetExecute(r)
}

/*
SecureFundsSymbolSwitchingFundsGet Method for SecureFundsSymbolSwitchingFundsGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param symbol
	@return ApiSecureFundsSymbolSwitchingFundsGetRequest
*/
func (a *FundAPIService) SecureFundsSymbolSwitchingFundsGet(ctx context.Context, symbol string) ApiSecureFundsSymbolSwitchingFundsGetRequest {
	return ApiSecureFundsSymbolSwitchingFundsGetRequest{
		ApiService: a,
		ctx:        ctx,
		symbol:     symbol,
	}
}

// Execute executes the request
//
//	@return PiFundMarketDataAPIModelsResponsesSwitchingFundResponseApiResponse
func (a *FundAPIService) SecureFundsSymbolSwitchingFundsGetExecute(r ApiSecureFundsSymbolSwitchingFundsGetRequest) (*PiFundMarketDataAPIModelsResponsesSwitchingFundResponseApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiFundMarketDataAPIModelsResponsesSwitchingFundResponseApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundAPIService.SecureFundsSymbolSwitchingFundsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/funds/{symbol}/switching-funds"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol"+"}", url.PathEscape(parameterValueToString(r.symbol, "symbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureFundsSymbolTradableDatesGetRequest struct {
	ctx          context.Context
	ApiService   *FundAPIService
	symbol       string
	tradeType    *PiFundMarketDataConstantsTradeSide
	switchSymbol *string
}

func (r ApiSecureFundsSymbolTradableDatesGetRequest) TradeType(tradeType PiFundMarketDataConstantsTradeSide) ApiSecureFundsSymbolTradableDatesGetRequest {
	r.tradeType = &tradeType
	return r
}

func (r ApiSecureFundsSymbolTradableDatesGetRequest) SwitchSymbol(switchSymbol string) ApiSecureFundsSymbolTradableDatesGetRequest {
	r.switchSymbol = &switchSymbol
	return r
}

func (r ApiSecureFundsSymbolTradableDatesGetRequest) Execute() (*SystemDateTimeIEnumerableApiResponse, *http.Response, error) {
	return r.ApiService.SecureFundsSymbolTradableDatesGetExecute(r)
}

/*
SecureFundsSymbolTradableDatesGet Method for SecureFundsSymbolTradableDatesGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param symbol
	@return ApiSecureFundsSymbolTradableDatesGetRequest
*/
func (a *FundAPIService) SecureFundsSymbolTradableDatesGet(ctx context.Context, symbol string) ApiSecureFundsSymbolTradableDatesGetRequest {
	return ApiSecureFundsSymbolTradableDatesGetRequest{
		ApiService: a,
		ctx:        ctx,
		symbol:     symbol,
	}
}

// Execute executes the request
//
//	@return SystemDateTimeIEnumerableApiResponse
func (a *FundAPIService) SecureFundsSymbolTradableDatesGetExecute(r ApiSecureFundsSymbolTradableDatesGetRequest) (*SystemDateTimeIEnumerableApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SystemDateTimeIEnumerableApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundAPIService.SecureFundsSymbolTradableDatesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/funds/{symbol}/tradable-dates"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol"+"}", url.PathEscape(parameterValueToString(r.symbol, "symbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tradeType == nil {
		return localVarReturnValue, nil, reportError("tradeType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "TradeType", r.tradeType, "form", "")
	if r.switchSymbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SwitchSymbol", r.switchSymbol, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureLegacyFundsSummariesPostRequest struct {
	ctx                                                   context.Context
	ApiService                                            *FundAPIService
	piFundMarketDataAPIModelsRequestsLegacySymbolsRequest *PiFundMarketDataAPIModelsRequestsLegacySymbolsRequest
}

func (r ApiSecureLegacyFundsSummariesPostRequest) PiFundMarketDataAPIModelsRequestsLegacySymbolsRequest(piFundMarketDataAPIModelsRequestsLegacySymbolsRequest PiFundMarketDataAPIModelsRequestsLegacySymbolsRequest) ApiSecureLegacyFundsSummariesPostRequest {
	r.piFundMarketDataAPIModelsRequestsLegacySymbolsRequest = &piFundMarketDataAPIModelsRequestsLegacySymbolsRequest
	return r
}

func (r ApiSecureLegacyFundsSummariesPostRequest) Execute() (*PiFundMarketDataAPIModelsResponsesLegacyFundMarketSummaryResponseIEnumerableApiResponse, *http.Response, error) {
	return r.ApiService.SecureLegacyFundsSummariesPostExecute(r)
}

/*
SecureLegacyFundsSummariesPost Method for SecureLegacyFundsSummariesPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureLegacyFundsSummariesPostRequest
*/
func (a *FundAPIService) SecureLegacyFundsSummariesPost(ctx context.Context) ApiSecureLegacyFundsSummariesPostRequest {
	return ApiSecureLegacyFundsSummariesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiFundMarketDataAPIModelsResponsesLegacyFundMarketSummaryResponseIEnumerableApiResponse
func (a *FundAPIService) SecureLegacyFundsSummariesPostExecute(r ApiSecureLegacyFundsSummariesPostRequest) (*PiFundMarketDataAPIModelsResponsesLegacyFundMarketSummaryResponseIEnumerableApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiFundMarketDataAPIModelsResponsesLegacyFundMarketSummaryResponseIEnumerableApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FundAPIService.SecureLegacyFundsSummariesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/legacy/funds/summaries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.piFundMarketDataAPIModelsRequestsLegacySymbolsRequest == nil {
		return localVarReturnValue, nil, reportError("piFundMarketDataAPIModelsRequestsLegacySymbolsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.piFundMarketDataAPIModelsRequestsLegacySymbolsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
