/*
Pi.SetService.API, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package go_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

// SetTradingAPIService SetTradingAPI service
type SetTradingAPIService service

type ApiInternalAccountsBalanceSummaryGetRequest struct {
	ctx              context.Context
	ApiService       *SetTradingAPIService
	userId           *string
	tradingAccountNo *string
}

func (r ApiInternalAccountsBalanceSummaryGetRequest) UserId(userId string) ApiInternalAccountsBalanceSummaryGetRequest {
	r.userId = &userId
	return r
}

func (r ApiInternalAccountsBalanceSummaryGetRequest) TradingAccountNo(tradingAccountNo string) ApiInternalAccountsBalanceSummaryGetRequest {
	r.tradingAccountNo = &tradingAccountNo
	return r
}

func (r ApiInternalAccountsBalanceSummaryGetRequest) Execute() (*PiSetServiceAPIModelsSetAccountSummaryResponseListApiResponse, *http.Response, error) {
	return r.ApiService.InternalAccountsBalanceSummaryGetExecute(r)
}

/*
InternalAccountsBalanceSummaryGet Method for InternalAccountsBalanceSummaryGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInternalAccountsBalanceSummaryGetRequest
*/
func (a *SetTradingAPIService) InternalAccountsBalanceSummaryGet(ctx context.Context) ApiInternalAccountsBalanceSummaryGetRequest {
	return ApiInternalAccountsBalanceSummaryGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetAccountSummaryResponseListApiResponse
func (a *SetTradingAPIService) InternalAccountsBalanceSummaryGetExecute(r ApiInternalAccountsBalanceSummaryGetRequest) (*PiSetServiceAPIModelsSetAccountSummaryResponseListApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetAccountSummaryResponseListApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.InternalAccountsBalanceSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/internal/accounts/balance/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	if r.tradingAccountNo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tradingAccountNo", r.tradingAccountNo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureAccountsAvailableBalancePostRequest struct {
	ctx                                                           context.Context
	ApiService                                                    *SetTradingAPIService
	userId                                                        *string
	piSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest *PiSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest
}

func (r ApiSecureAccountsAvailableBalancePostRequest) UserId(userId string) ApiSecureAccountsAvailableBalancePostRequest {
	r.userId = &userId
	return r
}

func (r ApiSecureAccountsAvailableBalancePostRequest) PiSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest(piSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest PiSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest) ApiSecureAccountsAvailableBalancePostRequest {
	r.piSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest = &piSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest
	return r
}

func (r ApiSecureAccountsAvailableBalancePostRequest) Execute() (*PiSetServiceAPIModelsAccountInstrumentAvailableBalanceResponseApiResponse, *http.Response, error) {
	return r.ApiService.SecureAccountsAvailableBalancePostExecute(r)
}

/*
SecureAccountsAvailableBalancePost Method for SecureAccountsAvailableBalancePost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureAccountsAvailableBalancePostRequest
*/
func (a *SetTradingAPIService) SecureAccountsAvailableBalancePost(ctx context.Context) ApiSecureAccountsAvailableBalancePostRequest {
	return ApiSecureAccountsAvailableBalancePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsAccountInstrumentAvailableBalanceResponseApiResponse
func (a *SetTradingAPIService) SecureAccountsAvailableBalancePostExecute(r ApiSecureAccountsAvailableBalancePostRequest) (*PiSetServiceAPIModelsAccountInstrumentAvailableBalanceResponseApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsAccountInstrumentAvailableBalanceResponseApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.SecureAccountsAvailableBalancePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/accounts/available/balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.piSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest == nil {
		return localVarReturnValue, nil, reportError("piSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	// body params
	localVarPostBody = r.piSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureAccountsCashBalanceAssetsGetRequest struct {
	ctx              context.Context
	ApiService       *SetTradingAPIService
	userId           *string
	tradingAccountNo *string
}

func (r ApiSecureAccountsCashBalanceAssetsGetRequest) UserId(userId string) ApiSecureAccountsCashBalanceAssetsGetRequest {
	r.userId = &userId
	return r
}

func (r ApiSecureAccountsCashBalanceAssetsGetRequest) TradingAccountNo(tradingAccountNo string) ApiSecureAccountsCashBalanceAssetsGetRequest {
	r.tradingAccountNo = &tradingAccountNo
	return r
}

func (r ApiSecureAccountsCashBalanceAssetsGetRequest) Execute() (*PiSetServiceAPIModelsSetAccountAssetsResponseListApiResponse, *http.Response, error) {
	return r.ApiService.SecureAccountsCashBalanceAssetsGetExecute(r)
}

/*
SecureAccountsCashBalanceAssetsGet Method for SecureAccountsCashBalanceAssetsGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureAccountsCashBalanceAssetsGetRequest
*/
func (a *SetTradingAPIService) SecureAccountsCashBalanceAssetsGet(ctx context.Context) ApiSecureAccountsCashBalanceAssetsGetRequest {
	return ApiSecureAccountsCashBalanceAssetsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetAccountAssetsResponseListApiResponse
func (a *SetTradingAPIService) SecureAccountsCashBalanceAssetsGetExecute(r ApiSecureAccountsCashBalanceAssetsGetRequest) (*PiSetServiceAPIModelsSetAccountAssetsResponseListApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetAccountAssetsResponseListApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.SecureAccountsCashBalanceAssetsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/accounts/cash/balance/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.tradingAccountNo == nil {
		return localVarReturnValue, nil, reportError("tradingAccountNo is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tradingAccountNo", r.tradingAccountNo, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureAccountsCashBalanceInfoGetRequest struct {
	ctx              context.Context
	ApiService       *SetTradingAPIService
	userId           *string
	tradingAccountNo *string
}

func (r ApiSecureAccountsCashBalanceInfoGetRequest) UserId(userId string) ApiSecureAccountsCashBalanceInfoGetRequest {
	r.userId = &userId
	return r
}

func (r ApiSecureAccountsCashBalanceInfoGetRequest) TradingAccountNo(tradingAccountNo string) ApiSecureAccountsCashBalanceInfoGetRequest {
	r.tradingAccountNo = &tradingAccountNo
	return r
}

func (r ApiSecureAccountsCashBalanceInfoGetRequest) Execute() (*PiSetServiceAPIModelsSetAccountCashBalanceInfoResponseApiResponse, *http.Response, error) {
	return r.ApiService.SecureAccountsCashBalanceInfoGetExecute(r)
}

/*
SecureAccountsCashBalanceInfoGet Method for SecureAccountsCashBalanceInfoGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureAccountsCashBalanceInfoGetRequest
*/
func (a *SetTradingAPIService) SecureAccountsCashBalanceInfoGet(ctx context.Context) ApiSecureAccountsCashBalanceInfoGetRequest {
	return ApiSecureAccountsCashBalanceInfoGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetAccountCashBalanceInfoResponseApiResponse
func (a *SetTradingAPIService) SecureAccountsCashBalanceInfoGetExecute(r ApiSecureAccountsCashBalanceInfoGetRequest) (*PiSetServiceAPIModelsSetAccountCashBalanceInfoResponseApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetAccountCashBalanceInfoResponseApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.SecureAccountsCashBalanceInfoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/accounts/cash/balance/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.tradingAccountNo == nil {
		return localVarReturnValue, nil, reportError("tradingAccountNo is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tradingAccountNo", r.tradingAccountNo, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureAccountsCashBalanceSummaryGetRequest struct {
	ctx              context.Context
	ApiService       *SetTradingAPIService
	userId           *string
	tradingAccountNo *string
}

func (r ApiSecureAccountsCashBalanceSummaryGetRequest) UserId(userId string) ApiSecureAccountsCashBalanceSummaryGetRequest {
	r.userId = &userId
	return r
}

func (r ApiSecureAccountsCashBalanceSummaryGetRequest) TradingAccountNo(tradingAccountNo string) ApiSecureAccountsCashBalanceSummaryGetRequest {
	r.tradingAccountNo = &tradingAccountNo
	return r
}

func (r ApiSecureAccountsCashBalanceSummaryGetRequest) Execute() (*PiSetServiceAPIModelsSetAccountSummaryResponseApiResponse, *http.Response, error) {
	return r.ApiService.SecureAccountsCashBalanceSummaryGetExecute(r)
}

/*
SecureAccountsCashBalanceSummaryGet Method for SecureAccountsCashBalanceSummaryGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureAccountsCashBalanceSummaryGetRequest
*/
func (a *SetTradingAPIService) SecureAccountsCashBalanceSummaryGet(ctx context.Context) ApiSecureAccountsCashBalanceSummaryGetRequest {
	return ApiSecureAccountsCashBalanceSummaryGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetAccountSummaryResponseApiResponse
func (a *SetTradingAPIService) SecureAccountsCashBalanceSummaryGetExecute(r ApiSecureAccountsCashBalanceSummaryGetRequest) (*PiSetServiceAPIModelsSetAccountSummaryResponseApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetAccountSummaryResponseApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.SecureAccountsCashBalanceSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/accounts/cash/balance/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.tradingAccountNo == nil {
		return localVarReturnValue, nil, reportError("tradingAccountNo is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tradingAccountNo", r.tradingAccountNo, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureAccountsCreditBalanceAssetsGetRequest struct {
	ctx              context.Context
	ApiService       *SetTradingAPIService
	userId           *string
	tradingAccountNo *string
}

func (r ApiSecureAccountsCreditBalanceAssetsGetRequest) UserId(userId string) ApiSecureAccountsCreditBalanceAssetsGetRequest {
	r.userId = &userId
	return r
}

func (r ApiSecureAccountsCreditBalanceAssetsGetRequest) TradingAccountNo(tradingAccountNo string) ApiSecureAccountsCreditBalanceAssetsGetRequest {
	r.tradingAccountNo = &tradingAccountNo
	return r
}

func (r ApiSecureAccountsCreditBalanceAssetsGetRequest) Execute() (*PiSetServiceAPIModelsSetAccountAssetsResponseListApiResponse, *http.Response, error) {
	return r.ApiService.SecureAccountsCreditBalanceAssetsGetExecute(r)
}

/*
SecureAccountsCreditBalanceAssetsGet Method for SecureAccountsCreditBalanceAssetsGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureAccountsCreditBalanceAssetsGetRequest
*/
func (a *SetTradingAPIService) SecureAccountsCreditBalanceAssetsGet(ctx context.Context) ApiSecureAccountsCreditBalanceAssetsGetRequest {
	return ApiSecureAccountsCreditBalanceAssetsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetAccountAssetsResponseListApiResponse
func (a *SetTradingAPIService) SecureAccountsCreditBalanceAssetsGetExecute(r ApiSecureAccountsCreditBalanceAssetsGetRequest) (*PiSetServiceAPIModelsSetAccountAssetsResponseListApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetAccountAssetsResponseListApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.SecureAccountsCreditBalanceAssetsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/accounts/credit/balance/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.tradingAccountNo == nil {
		return localVarReturnValue, nil, reportError("tradingAccountNo is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tradingAccountNo", r.tradingAccountNo, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureAccountsCreditBalanceInfoGetRequest struct {
	ctx              context.Context
	ApiService       *SetTradingAPIService
	userId           *string
	tradingAccountNo *string
}

func (r ApiSecureAccountsCreditBalanceInfoGetRequest) UserId(userId string) ApiSecureAccountsCreditBalanceInfoGetRequest {
	r.userId = &userId
	return r
}

func (r ApiSecureAccountsCreditBalanceInfoGetRequest) TradingAccountNo(tradingAccountNo string) ApiSecureAccountsCreditBalanceInfoGetRequest {
	r.tradingAccountNo = &tradingAccountNo
	return r
}

func (r ApiSecureAccountsCreditBalanceInfoGetRequest) Execute() (*PiSetServiceAPIModelsSetAccountCreditBalanceInfoResponseApiResponse, *http.Response, error) {
	return r.ApiService.SecureAccountsCreditBalanceInfoGetExecute(r)
}

/*
SecureAccountsCreditBalanceInfoGet Method for SecureAccountsCreditBalanceInfoGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureAccountsCreditBalanceInfoGetRequest
*/
func (a *SetTradingAPIService) SecureAccountsCreditBalanceInfoGet(ctx context.Context) ApiSecureAccountsCreditBalanceInfoGetRequest {
	return ApiSecureAccountsCreditBalanceInfoGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetAccountCreditBalanceInfoResponseApiResponse
func (a *SetTradingAPIService) SecureAccountsCreditBalanceInfoGetExecute(r ApiSecureAccountsCreditBalanceInfoGetRequest) (*PiSetServiceAPIModelsSetAccountCreditBalanceInfoResponseApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetAccountCreditBalanceInfoResponseApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.SecureAccountsCreditBalanceInfoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/accounts/credit/balance/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.tradingAccountNo == nil {
		return localVarReturnValue, nil, reportError("tradingAccountNo is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tradingAccountNo", r.tradingAccountNo, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureAccountsCreditBalanceSummaryGetRequest struct {
	ctx              context.Context
	ApiService       *SetTradingAPIService
	userId           *string
	tradingAccountNo *string
}

func (r ApiSecureAccountsCreditBalanceSummaryGetRequest) UserId(userId string) ApiSecureAccountsCreditBalanceSummaryGetRequest {
	r.userId = &userId
	return r
}

func (r ApiSecureAccountsCreditBalanceSummaryGetRequest) TradingAccountNo(tradingAccountNo string) ApiSecureAccountsCreditBalanceSummaryGetRequest {
	r.tradingAccountNo = &tradingAccountNo
	return r
}

func (r ApiSecureAccountsCreditBalanceSummaryGetRequest) Execute() (*PiSetServiceAPIModelsSetCreditBalanceAccountSummaryResponseApiResponse, *http.Response, error) {
	return r.ApiService.SecureAccountsCreditBalanceSummaryGetExecute(r)
}

/*
SecureAccountsCreditBalanceSummaryGet Method for SecureAccountsCreditBalanceSummaryGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureAccountsCreditBalanceSummaryGetRequest
*/
func (a *SetTradingAPIService) SecureAccountsCreditBalanceSummaryGet(ctx context.Context) ApiSecureAccountsCreditBalanceSummaryGetRequest {
	return ApiSecureAccountsCreditBalanceSummaryGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetCreditBalanceAccountSummaryResponseApiResponse
func (a *SetTradingAPIService) SecureAccountsCreditBalanceSummaryGetExecute(r ApiSecureAccountsCreditBalanceSummaryGetRequest) (*PiSetServiceAPIModelsSetCreditBalanceAccountSummaryResponseApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetCreditBalanceAccountSummaryResponseApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.SecureAccountsCreditBalanceSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/accounts/credit/balance/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.tradingAccountNo == nil {
		return localVarReturnValue, nil, reportError("tradingAccountNo is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tradingAccountNo", r.tradingAccountNo, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureAccountsOpenordersGetRequest struct {
	ctx              context.Context
	ApiService       *SetTradingAPIService
	userId           *string
	tradingAccountNo *string
}

func (r ApiSecureAccountsOpenordersGetRequest) UserId(userId string) ApiSecureAccountsOpenordersGetRequest {
	r.userId = &userId
	return r
}

func (r ApiSecureAccountsOpenordersGetRequest) TradingAccountNo(tradingAccountNo string) ApiSecureAccountsOpenordersGetRequest {
	r.tradingAccountNo = &tradingAccountNo
	return r
}

func (r ApiSecureAccountsOpenordersGetRequest) Execute() (*PiSetServiceAPIModelsSetOpenOrderResponseListApiResponse, *http.Response, error) {
	return r.ApiService.SecureAccountsOpenordersGetExecute(r)
}

/*
SecureAccountsOpenordersGet Method for SecureAccountsOpenordersGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureAccountsOpenordersGetRequest
*/
func (a *SetTradingAPIService) SecureAccountsOpenordersGet(ctx context.Context) ApiSecureAccountsOpenordersGetRequest {
	return ApiSecureAccountsOpenordersGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetOpenOrderResponseListApiResponse
func (a *SetTradingAPIService) SecureAccountsOpenordersGetExecute(r ApiSecureAccountsOpenordersGetRequest) (*PiSetServiceAPIModelsSetOpenOrderResponseListApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetOpenOrderResponseListApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.SecureAccountsOpenordersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/accounts/openorders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.tradingAccountNo == nil {
		return localVarReturnValue, nil, reportError("tradingAccountNo is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tradingAccountNo", r.tradingAccountNo, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureAccountsSblAvailableBalancePostRequest struct {
	ctx                                                           context.Context
	ApiService                                                    *SetTradingAPIService
	userId                                                        *string
	piSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest *PiSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest
}

func (r ApiSecureAccountsSblAvailableBalancePostRequest) UserId(userId string) ApiSecureAccountsSblAvailableBalancePostRequest {
	r.userId = &userId
	return r
}

func (r ApiSecureAccountsSblAvailableBalancePostRequest) PiSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest(piSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest PiSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest) ApiSecureAccountsSblAvailableBalancePostRequest {
	r.piSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest = &piSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest
	return r
}

func (r ApiSecureAccountsSblAvailableBalancePostRequest) Execute() (*PiSetServiceAPIModelsAccountSblInstrumentAvailableBalanceResponseApiResponse, *http.Response, error) {
	return r.ApiService.SecureAccountsSblAvailableBalancePostExecute(r)
}

/*
SecureAccountsSblAvailableBalancePost Method for SecureAccountsSblAvailableBalancePost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureAccountsSblAvailableBalancePostRequest
*/
func (a *SetTradingAPIService) SecureAccountsSblAvailableBalancePost(ctx context.Context) ApiSecureAccountsSblAvailableBalancePostRequest {
	return ApiSecureAccountsSblAvailableBalancePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsAccountSblInstrumentAvailableBalanceResponseApiResponse
func (a *SetTradingAPIService) SecureAccountsSblAvailableBalancePostExecute(r ApiSecureAccountsSblAvailableBalancePostRequest) (*PiSetServiceAPIModelsAccountSblInstrumentAvailableBalanceResponseApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsAccountSblInstrumentAvailableBalanceResponseApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.SecureAccountsSblAvailableBalancePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/accounts/sbl/available/balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.piSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest == nil {
		return localVarReturnValue, nil, reportError("piSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	// body params
	localVarPostBody = r.piSetServiceAPIModelsAccountInstrumentAvailableBalanceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureInstrumentsEquityMarginRateGetRequest struct {
	ctx        context.Context
	ApiService *SetTradingAPIService
	symbol     *string
}

func (r ApiSecureInstrumentsEquityMarginRateGetRequest) Symbol(symbol string) ApiSecureInstrumentsEquityMarginRateGetRequest {
	r.symbol = &symbol
	return r
}

func (r ApiSecureInstrumentsEquityMarginRateGetRequest) Execute() (*PiSetServiceAPIModelsMarginRateResponseApiResponse, *http.Response, error) {
	return r.ApiService.SecureInstrumentsEquityMarginRateGetExecute(r)
}

/*
SecureInstrumentsEquityMarginRateGet Method for SecureInstrumentsEquityMarginRateGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureInstrumentsEquityMarginRateGetRequest
*/
func (a *SetTradingAPIService) SecureInstrumentsEquityMarginRateGet(ctx context.Context) ApiSecureInstrumentsEquityMarginRateGetRequest {
	return ApiSecureInstrumentsEquityMarginRateGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsMarginRateResponseApiResponse
func (a *SetTradingAPIService) SecureInstrumentsEquityMarginRateGetExecute(r ApiSecureInstrumentsEquityMarginRateGetRequest) (*PiSetServiceAPIModelsMarginRateResponseApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsMarginRateResponseApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.SecureInstrumentsEquityMarginRateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/instruments/equity/margin-rate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureOrdersCancelPostRequest struct {
	ctx                                     context.Context
	ApiService                              *SetTradingAPIService
	userId                                  *string
	piSetServiceAPIModelsCancelOrderRequest *PiSetServiceAPIModelsCancelOrderRequest
}

func (r ApiSecureOrdersCancelPostRequest) UserId(userId string) ApiSecureOrdersCancelPostRequest {
	r.userId = &userId
	return r
}

func (r ApiSecureOrdersCancelPostRequest) PiSetServiceAPIModelsCancelOrderRequest(piSetServiceAPIModelsCancelOrderRequest PiSetServiceAPIModelsCancelOrderRequest) ApiSecureOrdersCancelPostRequest {
	r.piSetServiceAPIModelsCancelOrderRequest = &piSetServiceAPIModelsCancelOrderRequest
	return r
}

func (r ApiSecureOrdersCancelPostRequest) Execute() (*PiSetServiceAPIModelsSetOrderApiResponse, *http.Response, error) {
	return r.ApiService.SecureOrdersCancelPostExecute(r)
}

/*
SecureOrdersCancelPost Method for SecureOrdersCancelPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureOrdersCancelPostRequest
*/
func (a *SetTradingAPIService) SecureOrdersCancelPost(ctx context.Context) ApiSecureOrdersCancelPostRequest {
	return ApiSecureOrdersCancelPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetOrderApiResponse
func (a *SetTradingAPIService) SecureOrdersCancelPostExecute(r ApiSecureOrdersCancelPostRequest) (*PiSetServiceAPIModelsSetOrderApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetOrderApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.SecureOrdersCancelPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/orders/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	// body params
	localVarPostBody = r.piSetServiceAPIModelsCancelOrderRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureOrdersChangePatchRequest struct {
	ctx                                     context.Context
	ApiService                              *SetTradingAPIService
	userId                                  *string
	piSetServiceAPIModelsChangeOrderRequest *PiSetServiceAPIModelsChangeOrderRequest
}

func (r ApiSecureOrdersChangePatchRequest) UserId(userId string) ApiSecureOrdersChangePatchRequest {
	r.userId = &userId
	return r
}

func (r ApiSecureOrdersChangePatchRequest) PiSetServiceAPIModelsChangeOrderRequest(piSetServiceAPIModelsChangeOrderRequest PiSetServiceAPIModelsChangeOrderRequest) ApiSecureOrdersChangePatchRequest {
	r.piSetServiceAPIModelsChangeOrderRequest = &piSetServiceAPIModelsChangeOrderRequest
	return r
}

func (r ApiSecureOrdersChangePatchRequest) Execute() (*PiSetServiceAPIModelsSetOrderApiResponse, *http.Response, error) {
	return r.ApiService.SecureOrdersChangePatchExecute(r)
}

/*
SecureOrdersChangePatch Method for SecureOrdersChangePatch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureOrdersChangePatchRequest
*/
func (a *SetTradingAPIService) SecureOrdersChangePatch(ctx context.Context) ApiSecureOrdersChangePatchRequest {
	return ApiSecureOrdersChangePatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetOrderApiResponse
func (a *SetTradingAPIService) SecureOrdersChangePatchExecute(r ApiSecureOrdersChangePatchRequest) (*PiSetServiceAPIModelsSetOrderApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetOrderApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.SecureOrdersChangePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/orders/change"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	// body params
	localVarPostBody = r.piSetServiceAPIModelsChangeOrderRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureOrdersHistoriesConfirmGetRequest struct {
	ctx              context.Context
	ApiService       *SetTradingAPIService
	userId           *string
	tradingAccountNo *string
	startDate        *string
	endDate          *string
	limit            *string
	offSet           *string
}

func (r ApiSecureOrdersHistoriesConfirmGetRequest) UserId(userId string) ApiSecureOrdersHistoriesConfirmGetRequest {
	r.userId = &userId
	return r
}

func (r ApiSecureOrdersHistoriesConfirmGetRequest) TradingAccountNo(tradingAccountNo string) ApiSecureOrdersHistoriesConfirmGetRequest {
	r.tradingAccountNo = &tradingAccountNo
	return r
}

func (r ApiSecureOrdersHistoriesConfirmGetRequest) StartDate(startDate string) ApiSecureOrdersHistoriesConfirmGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSecureOrdersHistoriesConfirmGetRequest) EndDate(endDate string) ApiSecureOrdersHistoriesConfirmGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSecureOrdersHistoriesConfirmGetRequest) Limit(limit string) ApiSecureOrdersHistoriesConfirmGetRequest {
	r.limit = &limit
	return r
}

func (r ApiSecureOrdersHistoriesConfirmGetRequest) OffSet(offSet string) ApiSecureOrdersHistoriesConfirmGetRequest {
	r.offSet = &offSet
	return r
}

func (r ApiSecureOrdersHistoriesConfirmGetRequest) Execute() (*PiSetServiceAPIModelsSetTradeHistoryResponseListApiResponse, *http.Response, error) {
	return r.ApiService.SecureOrdersHistoriesConfirmGetExecute(r)
}

/*
SecureOrdersHistoriesConfirmGet Method for SecureOrdersHistoriesConfirmGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureOrdersHistoriesConfirmGetRequest
*/
func (a *SetTradingAPIService) SecureOrdersHistoriesConfirmGet(ctx context.Context) ApiSecureOrdersHistoriesConfirmGetRequest {
	return ApiSecureOrdersHistoriesConfirmGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetTradeHistoryResponseListApiResponse
func (a *SetTradingAPIService) SecureOrdersHistoriesConfirmGetExecute(r ApiSecureOrdersHistoriesConfirmGetRequest) (*PiSetServiceAPIModelsSetTradeHistoryResponseListApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetTradeHistoryResponseListApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.SecureOrdersHistoriesConfirmGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/orders/histories/confirm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.tradingAccountNo == nil {
		return localVarReturnValue, nil, reportError("tradingAccountNo is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tradingAccountNo", r.tradingAccountNo, "form", "")
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offSet != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offSet", r.offSet, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureOrdersHistoriesOpenGetRequest struct {
	ctx              context.Context
	ApiService       *SetTradingAPIService
	userId           *string
	tradingAccountNo *string
	startDate        *string
	endDate          *string
	limit            *string
	offSet           *string
}

func (r ApiSecureOrdersHistoriesOpenGetRequest) UserId(userId string) ApiSecureOrdersHistoriesOpenGetRequest {
	r.userId = &userId
	return r
}

func (r ApiSecureOrdersHistoriesOpenGetRequest) TradingAccountNo(tradingAccountNo string) ApiSecureOrdersHistoriesOpenGetRequest {
	r.tradingAccountNo = &tradingAccountNo
	return r
}

func (r ApiSecureOrdersHistoriesOpenGetRequest) StartDate(startDate string) ApiSecureOrdersHistoriesOpenGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSecureOrdersHistoriesOpenGetRequest) EndDate(endDate string) ApiSecureOrdersHistoriesOpenGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSecureOrdersHistoriesOpenGetRequest) Limit(limit string) ApiSecureOrdersHistoriesOpenGetRequest {
	r.limit = &limit
	return r
}

func (r ApiSecureOrdersHistoriesOpenGetRequest) OffSet(offSet string) ApiSecureOrdersHistoriesOpenGetRequest {
	r.offSet = &offSet
	return r
}

func (r ApiSecureOrdersHistoriesOpenGetRequest) Execute() (*PiSetServiceAPIModelsSetOrderHistoryResponseListApiResponse, *http.Response, error) {
	return r.ApiService.SecureOrdersHistoriesOpenGetExecute(r)
}

/*
SecureOrdersHistoriesOpenGet Method for SecureOrdersHistoriesOpenGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureOrdersHistoriesOpenGetRequest
*/
func (a *SetTradingAPIService) SecureOrdersHistoriesOpenGet(ctx context.Context) ApiSecureOrdersHistoriesOpenGetRequest {
	return ApiSecureOrdersHistoriesOpenGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetOrderHistoryResponseListApiResponse
func (a *SetTradingAPIService) SecureOrdersHistoriesOpenGetExecute(r ApiSecureOrdersHistoriesOpenGetRequest) (*PiSetServiceAPIModelsSetOrderHistoryResponseListApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetOrderHistoryResponseListApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.SecureOrdersHistoriesOpenGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/orders/histories/open"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.tradingAccountNo == nil {
		return localVarReturnValue, nil, reportError("tradingAccountNo is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tradingAccountNo", r.tradingAccountNo, "form", "")
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offSet != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offSet", r.offSet, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecureOrdersPostRequest struct {
	ctx                                    context.Context
	ApiService                             *SetTradingAPIService
	userId                                 *string
	piSetServiceAPIModelsPlaceOrderRequest *PiSetServiceAPIModelsPlaceOrderRequest
}

func (r ApiSecureOrdersPostRequest) UserId(userId string) ApiSecureOrdersPostRequest {
	r.userId = &userId
	return r
}

func (r ApiSecureOrdersPostRequest) PiSetServiceAPIModelsPlaceOrderRequest(piSetServiceAPIModelsPlaceOrderRequest PiSetServiceAPIModelsPlaceOrderRequest) ApiSecureOrdersPostRequest {
	r.piSetServiceAPIModelsPlaceOrderRequest = &piSetServiceAPIModelsPlaceOrderRequest
	return r
}

func (r ApiSecureOrdersPostRequest) Execute() (*PiSetServiceAPIModelsSetOrderApiResponse, *http.Response, error) {
	return r.ApiService.SecureOrdersPostExecute(r)
}

/*
SecureOrdersPost Method for SecureOrdersPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecureOrdersPostRequest
*/
func (a *SetTradingAPIService) SecureOrdersPost(ctx context.Context) ApiSecureOrdersPostRequest {
	return ApiSecureOrdersPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetOrderApiResponse
func (a *SetTradingAPIService) SecureOrdersPostExecute(r ApiSecureOrdersPostRequest) (*PiSetServiceAPIModelsSetOrderApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetOrderApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.SecureOrdersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secure/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	// body params
	localVarPostBody = r.piSetServiceAPIModelsPlaceOrderRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTradingOrdersCancelPostRequest struct {
	ctx                                     context.Context
	ApiService                              *SetTradingAPIService
	userId                                  *string
	piSetServiceAPIModelsCancelOrderRequest *PiSetServiceAPIModelsCancelOrderRequest
}

func (r ApiTradingOrdersCancelPostRequest) UserId(userId string) ApiTradingOrdersCancelPostRequest {
	r.userId = &userId
	return r
}

func (r ApiTradingOrdersCancelPostRequest) PiSetServiceAPIModelsCancelOrderRequest(piSetServiceAPIModelsCancelOrderRequest PiSetServiceAPIModelsCancelOrderRequest) ApiTradingOrdersCancelPostRequest {
	r.piSetServiceAPIModelsCancelOrderRequest = &piSetServiceAPIModelsCancelOrderRequest
	return r
}

func (r ApiTradingOrdersCancelPostRequest) Execute() (*PiSetServiceAPIModelsSetOrderApiResponse, *http.Response, error) {
	return r.ApiService.TradingOrdersCancelPostExecute(r)
}

/*
TradingOrdersCancelPost Method for TradingOrdersCancelPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTradingOrdersCancelPostRequest
*/
func (a *SetTradingAPIService) TradingOrdersCancelPost(ctx context.Context) ApiTradingOrdersCancelPostRequest {
	return ApiTradingOrdersCancelPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetOrderApiResponse
func (a *SetTradingAPIService) TradingOrdersCancelPostExecute(r ApiTradingOrdersCancelPostRequest) (*PiSetServiceAPIModelsSetOrderApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetOrderApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.TradingOrdersCancelPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/trading/orders/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	// body params
	localVarPostBody = r.piSetServiceAPIModelsCancelOrderRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTradingOrdersChangePatchRequest struct {
	ctx                                     context.Context
	ApiService                              *SetTradingAPIService
	userId                                  *string
	piSetServiceAPIModelsChangeOrderRequest *PiSetServiceAPIModelsChangeOrderRequest
}

func (r ApiTradingOrdersChangePatchRequest) UserId(userId string) ApiTradingOrdersChangePatchRequest {
	r.userId = &userId
	return r
}

func (r ApiTradingOrdersChangePatchRequest) PiSetServiceAPIModelsChangeOrderRequest(piSetServiceAPIModelsChangeOrderRequest PiSetServiceAPIModelsChangeOrderRequest) ApiTradingOrdersChangePatchRequest {
	r.piSetServiceAPIModelsChangeOrderRequest = &piSetServiceAPIModelsChangeOrderRequest
	return r
}

func (r ApiTradingOrdersChangePatchRequest) Execute() (*PiSetServiceAPIModelsSetOrderApiResponse, *http.Response, error) {
	return r.ApiService.TradingOrdersChangePatchExecute(r)
}

/*
TradingOrdersChangePatch Method for TradingOrdersChangePatch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTradingOrdersChangePatchRequest
*/
func (a *SetTradingAPIService) TradingOrdersChangePatch(ctx context.Context) ApiTradingOrdersChangePatchRequest {
	return ApiTradingOrdersChangePatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetOrderApiResponse
func (a *SetTradingAPIService) TradingOrdersChangePatchExecute(r ApiTradingOrdersChangePatchRequest) (*PiSetServiceAPIModelsSetOrderApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetOrderApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.TradingOrdersChangePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/trading/orders/change"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	// body params
	localVarPostBody = r.piSetServiceAPIModelsChangeOrderRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTradingOrdersPostRequest struct {
	ctx                                    context.Context
	ApiService                             *SetTradingAPIService
	userId                                 *string
	piSetServiceAPIModelsPlaceOrderRequest *PiSetServiceAPIModelsPlaceOrderRequest
}

func (r ApiTradingOrdersPostRequest) UserId(userId string) ApiTradingOrdersPostRequest {
	r.userId = &userId
	return r
}

func (r ApiTradingOrdersPostRequest) PiSetServiceAPIModelsPlaceOrderRequest(piSetServiceAPIModelsPlaceOrderRequest PiSetServiceAPIModelsPlaceOrderRequest) ApiTradingOrdersPostRequest {
	r.piSetServiceAPIModelsPlaceOrderRequest = &piSetServiceAPIModelsPlaceOrderRequest
	return r
}

func (r ApiTradingOrdersPostRequest) Execute() (*PiSetServiceAPIModelsSetOrderApiResponse, *http.Response, error) {
	return r.ApiService.TradingOrdersPostExecute(r)
}

/*
TradingOrdersPost Method for TradingOrdersPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTradingOrdersPostRequest
*/
func (a *SetTradingAPIService) TradingOrdersPost(ctx context.Context) ApiTradingOrdersPostRequest {
	return ApiTradingOrdersPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PiSetServiceAPIModelsSetOrderApiResponse
func (a *SetTradingAPIService) TradingOrdersPostExecute(r ApiTradingOrdersPostRequest) (*PiSetServiceAPIModelsSetOrderApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PiSetServiceAPIModelsSetOrderApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SetTradingAPIService.TradingOrdersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/trading/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "user-id", r.userId, "simple", "")
	// body params
	localVarPostBody = r.piSetServiceAPIModelsPlaceOrderRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
